#### 背景介绍
“刷新太慢了，经常接近1000ms！”，这个困惑持续了相当长的一段时间。我们的刷新动作包含数据的查取、排序以及界面绘制。经过排查发现，排序会占用30%\~%50的时间，意味着1000ms的刷新，排序就用掉了300\~500ms，真正让人不解的是只有3000条数据而已，而且还用的是**快速排序**。

#### 简单的分析快排
都知道快速排序相对而言，是一种比较优质的排序方法，它比归并排序占用的空间少，比堆排序更友好(简单的说，这里的友好是针对CPU而言，堆排序是跳着访问的，而快排是顺序访问的)，而且时间复杂度的常量系数低（可以参考[这里](http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/)）。即使最坏的情况，纸面上的时间效率是O(n^2)，但其实它比同样是O(n^2)的冒泡等相关排序方法的效率要高。（这里就不详细展开了，你可以通过逆序度的方式分析一下，快排的常量系数的区间分布，大多数时候，比冒泡要小），更何况对快排而言，它的最坏情况出现的概率很小。

以上的分析仅仅是推测，实际情况如何呢？自己写了一个冒泡排序。然后对完全相同的数据排序后，发现平均耗时在150\~300ms之间。那么问题就很明显了，一定是快排的实现出了问题。抛弃系统的快排接口函数，自己写了个快排，好吧，平均耗时在10\~45ms之间。那么之前的快排到底出了什么问题呢？

#### 被玩坏的快速排序
那本[《编程珠玑》(第二版)](https://book.douban.com/subject/3227098/)里面有这么一句话，“C标准库函数qsort非常简单并且相对速度较快，它比我们自己写的快速排序**慢**，仅仅因为其通用而灵活的接口对每次比较都使用函数调用”。快排是原地排序，比较两个元素的大小无非是
  
    if (a > b)
      ......

对于基本数据类型的比较，当然可以这么写。但实际业务中，就不止基本数据类型。假设以下的结构体
    
    struct field_type {
        int A;
        float B;
        string S;
        ......
        struct typeOfClient t_client;
    };
    
    struct typeOfClient {
        char type_;
        string app_value;
        ......
    }
    
现在要按照不同的字段类型，进行排序。很明显，对于复杂类型的数据，在比较大小的方法上，无法简单的通过'>'、'<'或者'=='。比如现在按照`t_client`字段排序。以下代码：

    struct field_type X;
    struct field_type Y;
    if (X.t_client == Y.t_client) // 对象比较，需要对运算符‘==’进行重载
虽然t_client是结构体类型的一个字段，但界面上呈现出来的其实是t_client的app_value的属性值。因为t_client的类型是结构体typeOfClient，而这里对它的排序是按照该另一个成员变量 type_进行的。

| A        | B           | t_client  |
| -------- |:-----------:| ---------:|
| 1        | 101789651   | 风险率过高|
| 6        | 1097681983  | 头寸      |
| 2        | 10234832    | 出入金    |
| 3        | 9494311091  | 可提取    |

不同类型的字段，需要按照不同的策略进行比较。其实即使相同类型的字段，因为业务需求的问题，可能也需要不同的比较策略。假设两个string类型的字段C和D，对字段C，按照ASCII码比较大小。对字段D，按照业务类别比较，总之不是按照ASCII码。

    if (a > b) // 这种小而特殊的比较方法改为以下
    
    if (compare(fieldId)) // fieldId 表示待排序字段的Id，比如 fieldId == ‘A’，就表示对字段A排序，
    {
    }
    
    bool compare(fieldId)
    {
        if (fieldId == A) //字段A包含的数据类型是整型
        {
            // 比较A字段
        }
        
        ......
        
        
        if (fieldId == t_client)
        {
            // 比较Client字段
        }
    }
以上`field_type`中，只展示了四个字段，如果有多达数百个字段，很可能意味着compare方法中，得加入数百个比较策略。分析到这里，其实只是初始。可能还没有说明白，为什么快速排序被玩坏了。想想看，执行1000000次if(a > b)与执行相同次数的if(compare(a, b))的差异。那本《C++应用程序性能差异》一书中提到，调用函数本身就有一个固有的时间损耗，再加上执行函数体里面的语句。

    if (a > b) // 执行一百万次
    if (compare(a, b)) // 执行一百万次

另外，比较函数里面包含了对不同字段的比较策略。也就意味着进入到这个比较函数中，得先找到相应的字段，上面说了，如果有数百个字段，找到相应的字段，意味着你得进行数百次的比较。这其实已经是一个非常恐怖的性能损耗。更甚者，在几百层的if...else if ... else ... 中，对字段的比较包含着直接对字符串的比较，比如下面的代码。这种比较，每一次会生成一个临时对象，字符串的临时对象的生成，涉及调用一次构造函数然后析构等等。

      compare (string field_type)
      {
          if (fiel_type == "字段A")
          {
          }
          else if (fiel_type == "字段B")
          {
          }
          ....
          else
          {
          }
      }

主要的性能损耗大概说完了，其实还是少说了一些细节，比如函数返回值，比如递归调用这些的。不过从实际的数据测试来看，这些影响都是比较小的。那如何解决这些问题呢？还得从技术及业务角度考虑。
###### 技术层面
我们自己重新写排序算法，但最好根据数据规模可以动态的选择。比如当数据很少是，如少于100条记录，简单插入排序就是非常不错的选择，或者冒泡排序的，都可以。当大于100条时，可以提供时间复杂度为O(nlog(n))的排序算法。代码层面的优化，可以看我写的这篇[文章](https://github.com/WalkingNL/Performance/tree/master)。
###### 业务层面
相比于技术层面，在实际工作中，对业务的深入理解，对于优化工作也非常重要。比如我们有些字段的值其实只有两三种，有些字段是类似于电话号码的字符串，有些字段是浮点型，有些字段从后台拉取过来之后，基本上就不会变化等等。不同的字段，理解透彻之后，可以写出不同的排序方法，例如只有两三种值类型的字段，使用计数排序；值为类似电话号码的字段，使用基数排序，范围波动比较大的，使用桶排序。最后，只要写一个针对不同字段的调度接口，就行了。

#### 性能权衡

###### 一定要有取舍。
原始的接口虽然比较低效，但数据量小的话，时间效率完全可以接受。
###### 保证平衡性
优化是一项全局的任务，所以一定要要站在系统整体的角度进行分析，抓住主要矛盾。比如这里的**刷新**操作，排序几乎占掉了一半的时间，因此对排序的优化，能提升性能。反之，如果排序本身花费的时间虽高，但占用掉**刷新**操作的时间比很小的话，单纯的对排序优化是没有必要的。
###### 勿追求完美
在我看来，如果优化后，之前的性能问题，得到了很大的改善，在可估计的一段时间之类(比如5年以内)，完全够用，就暂时没必要再继续深入。但是，深入的分析，整理出可行性优化分析文档，非常重要。



