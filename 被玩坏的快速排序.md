#### 背景介绍
“刷新太慢了，经常接近1000ms！”，这个困惑持续了相当长的一段时间。我们的刷新动作包含数据的查取、排序以及界面绘制。经过排查发现，排序会占用30%\~%50的时间，意味着1000ms的刷新，排序就用掉了300\~500ms，真正让人不解的是只有3000条数据而已，而且还用的是**快速排序**。

#### 简单的分析快排
都知道快速排序相对而言，是一种比较优质的排序方法，它比归并排序占用的空间少，比堆排序更友好(简单的说，这里的友好是针对CPU而言，堆排序是跳着访问的，而快排是顺序访问的)，而且时间复杂度的常量系数低（可以参考[这里](http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/)）。即使最坏的情况，纸面上的时间效率是O(n^2)，但其实它比同样是O(n^2)的冒泡等相关排序方法的效率要高。（这里就不详细展开了，你可以通过逆序度的方式分析一下，快排的常量系数的区间分布，大多数时候，比冒泡要小），更何况对快排而言，它的最坏情况出现的概率很小。

以上的分析仅仅是推测，实际情况如何呢？自己写了一个冒泡排序。然后对完全相同的数据排序后，发现平均耗时在150\~300ms之间。那么问题就很明显了，一定是快排的实现出了问题。抛弃系统的快排接口函数，自己写了个快排，好吧，平均耗时在10\~45ms之间。那么之前的快排到底出了什么问题呢？

#### 被玩坏的快速排序
那本[《编程珠玑》(第二版)](https://book.douban.com/subject/3227098/)里面有这么一句话，“C标准库函数qsort非常简单并且相对速度较快，它比我们自己写的快速排序**慢**，仅仅因为其通用而灵活的接口对每次比较都使用函数调用”。快排是原地排序，比较两个元素的大小无非是
  
    if (a > b)
      ......

对于基本数据类型的比较，当然可以这么写。但实际业务中，就不止基本数据类型。假设以下的结构体
    
    struct field_type {
        int A;
        float B;
        string S;
        ......
        struct typeOfClient t_client;
    };
    
    struct typeOfClient {
        time_ t_;
        char type_;
        string name;
        ......
    }
    
现在要按照不同的字段类型，进行排序。很明显，对于复杂类型的数据，在比较大小的方法上，无法简单的通过'>'、'<'或者'=='。比如现在按照`t_client`字段排序。以下代码：

    struct field_type A;
    struct field_type B;
    if (A.t_client == B.t_client) // 对象比较，需要对运算符‘==’进行重载
虽然t_client是结构体类型的一个字段，但界面上呈现出来的


#### 不得已的性能取舍
